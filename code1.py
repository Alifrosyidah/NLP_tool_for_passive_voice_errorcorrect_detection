# -*- coding: utf-8 -*-
"""Dataset 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fxlu6T1XKJlUhNH7yH1mV8ALleCxX8ME

**Import Data and Matcher**
"""

import pandas as pd
import re
import spacy
from spacy.matcher import Matcher
nlp = spacy.load('en_core_web_sm',disable = ['textcat'])

# Load required libraries and models, and packages
# !python -m spacy download en_core_web_md
# !python -m spacy download en_core_web_lg

# load csv file first
import pandas as pd
import re
import spacy
from spacy.matcher import Matcher
nlp = spacy.load('en_core_web_sm',  disable = ['textcat'])

# Load required libraries and models, and packages
# !python -m spacy download en_core_web_md
# !python -m spacy download en_core_web_lg

# load csv file first
import pandas as pd
import re
import spacy
from spacy.matcher import Matcher
nlp = spacy.load('en_core_web_sm',  disable = ['textcat'])

# Load required libraries and models, and packages
# !python -m spacy download en_core_web_md
# !python -m spacy download en_core_web_lg

# load csv file first
# import csv file

df = pd.read_excel('/content/passive_voice.xlsx', usecols = ['text', 'correct', 'error'])

df.head() # add # or rows to view
# df.tail()
df

"""**Cleaning Texts**"""

def add_spaces_around_tags(text):
    return re.sub(r'(<c>|</c>|<e>|</e>)', r' \1 ', text)
df['new_text'] = df['text'].apply(add_spaces_around_tags)

df

# prompt: count the total token from all the texts

def count_tokens(text):
    doc = nlp(text)
    return len(doc)

df['token_count'] = df['new_text'].apply(count_tokens)

total_tokens = df['token_count'].sum()
print(f"Total tokens in all texts: {total_tokens}")

# prompt: print the number of
# Total Token
# Mean
# SD
# Min
# Max

mean_tokens = df['token_count'].mean()
sd_tokens = df['token_count'].std()
min_tokens = df['token_count'].min()
max_tokens = df['token_count'].max()

print(f"Total Tokens: {total_tokens}")
print(f"Mean: {mean_tokens}")
print(f"SD: {sd_tokens}")
print(f"Min: {min_tokens}")
print(f"Max: {max_tokens}")

# df.describe()
# df.value_counts()
df.shape # rows x columns

from spacy.matcher import Matcher
import spacy

# Load the spaCy model
nlp = spacy.load("en_core_web_sm")

def error(new_text):
    # Parse the input text
    doc = nlp(new_text)
    matcher = Matcher(nlp.vocab)

    # Define patterns for passive voice detection
    patterns = [
        #1 be + (VBN or verb base + suffix ed) (e.g., is eaten, was done, is crafted)
        [
            {"LEMMA": "be", "TAG": {"IN": ["VB", "VBD", "VBZ", "VBP", "AUX"]}},  # Auxiliary "be" as base form or past participle
             {"POS": "ADV", "OP": "?"},  # Optional adverb (e.g., strongly)
            {"TAG": "VBN"},  # Past participle
        ],

        [
            {"LEMMA": "be", "TAG": {"IN": ["VB", "VBD", "VBZ", "VBP", "AUX"]}},  # Auxiliary "be"
             {"POS": "ADV", "OP": "?"},  # Optional adverb (e.g., strongly)
            {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}  # Verb base + "ed"
        ],

        #2 modal auxiliary + optional "not" + "be" + (VBN or verb base + suffix ed)
        [
            {"TAG": "MD"},  # Modal auxiliary (e.g., will, might)
            {"LOWER": "not", "OP": "?"},  # Optional "not"
            {"LEMMA": "be", "TAG": "VB"},  # Auxiliary "be"
             {"POS": "ADV", "OP": "?"},  # Optional adverb (e.g., strongly)
            {"TAG": "VBN"},  # Past participle
        ],

        [
            {"TAG": "MD"},  # Modal auxiliary (e.g., will, might)
            {"LOWER": "not", "OP": "?"},  # Optional "not"
            {"LEMMA": "be", "TAG": "VB"},  # Auxiliary "be"
            {"POS": "ADV", "OP": "?"},  # Optional adverb (e.g., strongly)
            {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}  # Verb base + "ed"
        ],

       #3 modal auxiliary + have + been + VBN
       [
            {"TAG": "MD"},  # Modal auxiliary (e.g., will, might)
            {"LOWER": "not", "OP": "?"},  # Optional "not"
             {"LEMMA": "have", "POS": "AUX"}, # Match "have" or "has" as an auxiliary verb
            {"LEMMA": "be", "POS": {"IN": ["VBN", "AUX"]}},   # Match "been" as an auxiliary verb
             {"POS": "ADV", "OP": "?"},      # Optional adverb (e.g., "well")
              {"TAG": "VBN"} # Past participle (e.g., "protected")
        ],

        [
            {"TAG": "MD"},  # Modal auxiliary (e.g., will, might)
            {"LOWER": "not", "OP": "?"},  # Optional "not"
            {"LEMMA": "have", "POS": "AUX"}, # Match "have" or "has" as an auxiliary verb
            {"LEMMA": "be", "POS": {"IN": ["VBN", "AUX"]}},   # Match "been" as an auxiliary verb
             {"POS": "ADV", "OP": "?"},      # Optional adverb (e.g., "well")
            {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}  # Verb base + "ed"
        ],

       #4 (been + VBN)
       [
           {"LEMMA": "be", "TAG":"VBN"},
           {"TAG":"VBN"}
       ],

       [
           {"LEMMA": "be", "TAG": "VBN"}, # Fixed: Added a comma here
           {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}
       ],

       #5 S + have/has been ADV VBN
       [
           {"POS": "DET", "OP": "?"},        # Optional determiner (e.g., "A")
           {"TAG": "NN", "DEP": "nsubj"},    # Singular noun (e.g., "series")
            {"LEMMA": "have", "POS": "AUX"}, # Match "have" or "has" as an auxiliary verb
            {"LEMMA": "be", "POS": {"IN": ["VBN", "AUX"]}},   # Match "been" as an auxiliary verb
             {"POS": "ADV", "OP": "?"},      # Optional adverb (e.g., "well")
              {"TAG": "VBN"} # Past participle (e.g., "protected")
              ],

       [
           {"POS": "DET", "OP": "?"},        # Optional determiner (e.g., "A")
           {"TAG": "NN", "DEP": "nsubj"},    # Singular noun (e.g., "series")
            {"LEMMA": "have", "POS": "AUX"}, # Match "have" or "has" as an auxiliary verb
            {"LEMMA": "be", "POS": {"IN": ["VBN", "AUX"]}},   # Match "been" as an auxiliary verb
             {"POS": "ADV", "OP": "?"},      # Optional adverb (e.g., "well")
              {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}} # Past participle (e.g., "protected")
              ],

       #6 to be VBN
       [
           {"LOWER": "to", "POS": "PART"},
           {"LEMMA": "be", "POS": "AUX"},
           {"TAG": "VBN"}
       ],

       [
            {"LOWER": "to", "POS": "PART"},
           {"LEMMA": "be", "POS": "AUX"},
           {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}
       ],

       #7 MD "CAN"
       [
           {"LEMMA": "can", "POS":"AUX"}, # Modal auxiliary (e.g., "can", "can't)
           {"LOWER": "'t", "OP": "?"}, # Optional "not"
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}      # Past participle (e.g., "ignored")
       ],
       [
           {"LEMMA": "can", "POS": "AUX"}, # Modal auxiliary (e.g., "can", "can't)
           {"LOWER": "'t", "OP": "?"}, # Optional "not"
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}        # Past participle (e.g., "ignored")
       ],
       [
            {"LEMMA": "cannot", "POS": "AUX"}, # Modal auxiliary (e.g., "can", "can't)
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}      # Past participle (e.g., "ignored")
       ],

       [
           {"LEMMA": "cannot", "POS": "AUX"}, # Modal auxiliary (e.g., "can", "can't)
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}        # Past participle (e.g., "ignored")
       ],
       [
           {"LEMMA": "could", "POS": {"IN": ["VBD", "AUX"]}}, # Modal auxiliary (e.g., "can", "can't) # Fixed: Changed "IN" to {"IN": [...]}
            {"LOWER": "n't", "OP": "?"}, # Optional "not"
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}         # Past participle (e.g., "ignored")
       ],
       [
           {"LEMMA": "could", "POS": {"IN": ["VBD", "AUX"]}}, # Modal auxiliary (e.g., "can", "can't) # Fixed: Changed "IN" to {"IN": [...]}
            {"LOWER": "n't", "OP": "?"}, # Optional "not"
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}        # Past participle (e.g., "ignored")
       ],
       #8 MD "would" and "should"
       [
           {"LEMMA": {"IN": ["would", "should"]}, "POS": {"IN": ["AUX", "VB"]}},  # Modal auxiliaries # Fixed: Changed "IN": {"IN": [...]} to "IN": [...]
           {"LOWER": "not", "OP": "?"},
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}       # Past participle (e.g., "ignored")
       ],

       [
           {"LEMMA": {"IN": ["wouldn't", "shouldn't"]}, "POS": {"IN": ["VBD", "AUX"]}},  # Modal auxiliaries # Fixed: Changed "IN": to {"IN": [...]}
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}       # Past participle (e.g., "ignored")
       ],

       [
            {"LEMMA": {"IN": ["would", "should"]}, "POS": "AUX"},  # Modal auxiliaries
            {"LOWER": "not", "OP": "?"},
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
            {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}       # Past participle (e.g., "ignored")
       ],

       [
           {"LEMMA": {"IN": ["wouldn't", "shouldn't"]}, "POS": {"IN": ["VBD", "AUX"]}},  # Modal auxiliaries # Fixed: Changed "IN": to {"IN": [...]}
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}        # Past participle (e.g., "ignored")
       ],

       #9 MD "will"
       [
           {"LEMMA": "will", "POS": "AUX"},  # "will"
           {"LOWER": "not", "OP": "?"},      # Optional "not"
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
           {"TAG": "VBN"}        # Past participle (e.g., "ignored")
       ],
       [
           {"LEMMA": "will", "POS": "AUX"},  # "will"
           {"LOWER": "not", "OP": "?"},      # Optional "not"
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
           {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}       # Past participle (e.g., "ignored")
       ],

       [
           {"LOWER": "won't", "POS": "AUX"},  # "won't" as a single token
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
           {"TAG":"VBN"}        # Past participle (e.g., "ignored")
       ],

       [
           {"LOWER": "won't", "POS": "AUX"},  # "won't" as a single token
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
           {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}       # Past participle (e.g., "ignored")
       ]
    ]

    #The problematic line is properly indented now.
    matches = matcher(doc, as_spans=True)
    count = len(matches)

    for match in matches:
        print(match)

    return count

import pandas as pd

# Convert float to integer and NaN to zero
df['correct'] = df['correct'].astype(int)
df['error'] = df['error'].astype(int)
df
import re

# Original string
text = "<c>will be considered</c> and <e>is important</e>."

# Apply the regex to add spaces around <c>, </c>, <e>, and </e>
result = re.sub(r'(<c>|</c>|<e>|</e>)', r' \1 ', text)

print(result)

"""# Process texts and add a new column"""

# create a function to calculate length of each text

def text_length(x):
  x = x.lower().split()
  return len(x)

  import re

# Original string
text = "<c>will be considered</c> and <e>is important</e>."

# Apply the regex to add spaces around <c>, </c>, <e>, and </e>
result = re.sub(r'(<c>|</c>|<e>|</e>)', r' \1 ', text)

print(result)


  # apply function to each text in the dataframe
# & save results in a new column

df['TextLength'] = df['text'].apply(text_length)
df.head()

"""Detect 'correct' and 'error' patterns

Correct
"""

from spacy.matcher import Matcher
import spacy

# Load the spaCy model
nlp = spacy.load("en_core_web_sm")

def correct(new_text):
    # Parse the input text
    doc = nlp(new_text)
    matcher = Matcher(nlp.vocab)  # Fixed the incorrect initialization of Matcher

     # Define patterns for passive voice detection
    patterns = [
        #1 be + (VBN or verb base + suffix ed) (e.g., is eaten, was done, is crafted)
       [


    {"LEMMA": "be", "TAG": {"IN": ["VB", "VBD", "VBZ", "VBP", "AUX"]}},  # Auxiliary "be"
    {"POS": "ADV", "OP": "?"},  # Optional adverb (e.g., strongly)
    {"TAG": "VBN", "LEMMA": {"NOT_IN": ["learn", "come", "exist" "happen", "occur", "seem", "appear", "belong", "go", "come", "arrive", "depart", "walked", "run", "sleep", "die", "lie", "fall", "sit","rise", "belong", "consist", "have", "contain", "resemble", "lack", "depend", "fit", "cost"]}},
],

        [
            {"LEMMA": "be", "TAG": {"IN": ["VB", "VBD", "VBZ", "VBP", "AUX"]}},  # Auxiliary "be"
             {"POS": "ADV", "OP": "?"},  # Optional adverb (e.g., strongly)
            {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}  # Verb base + "ed"
        ],

        #2 modal auxiliary + optional "not" + "be" + (VBN or verb base + suffix ed)
        [
            {"TAG": "MD"},  # Modal auxiliary (e.g., will, might)
            {"LOWER": "not", "OP": "?"},  # Optional "not"
            {"LEMMA": "be", "TAG": "VB"},  # Auxiliary "be"
             {"POS": "ADV", "OP": "?"},  # Optional adverb (e.g., strongly)
            {"TAG": "VBN"},  # Past participle
        ],

        [
            {"TAG": "MD"},  # Modal auxiliary (e.g., will, might)
            {"LOWER": "not", "OP": "?"},  # Optional "not"
            {"LEMMA": "be", "TAG": "VB"},  # Auxiliary "be"
            {"POS": "ADV", "OP": "?"},  # Optional adverb (e.g., strongly)
            {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}  # Verb base + "ed"
        ],

       #3 modal auxiliary + have + been + VBN
       [
            {"TAG": "MD"},  # Modal auxiliary (e.g., will, might)
            {"LOWER": "not", "OP": "?"},  # Optional "not"
             {"LEMMA": "have", "POS": "AUX"}, # Match "have" or "has" as an auxiliary verb
            {"LEMMA": "be", "POS": {"IN": ["VBN", "AUX"]}},   # Match "been" as an auxiliary verb
             {"POS": "ADV", "OP": "?"},      # Optional adverb (e.g., "well")
              {"TAG": "VBN"} # Past participle (e.g., "protected")
        ],

        [
            {"TAG": "MD"},  # Modal auxiliary (e.g., will, might)
            {"LOWER": "not", "OP": "?"},  # Optional "not"
            {"LEMMA": "have", "POS": "AUX"}, # Match "have" or "has" as an auxiliary verb
            {"LEMMA": "be", "POS": {"IN": ["VBN", "AUX"]}},   # Match "been" as an auxiliary verb
             {"POS": "ADV", "OP": "?"},      # Optional adverb (e.g., "well")
            {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}  # Verb base + "ed"
        ],

       #4 (been + VBN)
       [
           {"LEMMA": "be", "TAG":"VBN"},
           {"TAG":"VBN"}
       ],

       [
           {"LEMMA": "be", "TAG": "VBN"}, # Fixed: Added a comma here
           {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}
       ],

       #5 S + have/has been ADV VBN
       [
           {"POS": "DET", "OP": "?"},        # Optional determiner (e.g., "A")
           {"TAG": "NN", "DEP": "nsubj"},    # Singular noun (e.g., "series")
            {"LEMMA": "have", "POS": "AUX"}, # Match "have" or "has" as an auxiliary verb
            {"LEMMA": "be", "POS": {"IN": ["VBN", "AUX"]}},   # Match "been" as an auxiliary verb
             {"POS": "ADV", "OP": "?"},      # Optional adverb (e.g., "well")
              {"TAG": "VBN"} # Past participle (e.g., "protected")
              ],

       [
           {"POS": "DET", "OP": "?"},        # Optional determiner (e.g., "A")
           {"TAG": "NN", "DEP": "nsubj"},    # Singular noun (e.g., "series")
            {"LEMMA": "have", "POS": "AUX"}, # Match "have" or "has" as an auxiliary verb
            {"LEMMA": "be", "POS": {"IN": ["VBN", "AUX"]}},   # Match "been" as an auxiliary verb
             {"POS": "ADV", "OP": "?"},      # Optional adverb (e.g., "well")
              {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}} # Past participle (e.g., "protected")
              ],

       #6 to be VBN
       [
           {"LOWER": "to", "POS": "PART"},
           {"LEMMA": "be", "POS": "AUX"},
           {"TAG": "VBN"}
       ],

       [
            {"LOWER": "to", "POS": "PART"},
           {"LEMMA": "be", "POS": "AUX"},
           {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}
       ],

       #7 MD "CAN"
       [
           {"LEMMA": "can", "POS":"AUX"}, # Modal auxiliary (e.g., "can", "can't)
           {"LOWER": "'t", "OP": "?"}, # Optional "not"
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}      # Past participle (e.g., "ignored")
       ],
       [
           {"LEMMA": "can", "POS": "AUX"}, # Modal auxiliary (e.g., "can", "can't)
           {"LOWER": "'t", "OP": "?"}, # Optional "not"
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}        # Past participle (e.g., "ignored")
       ],
       [
            {"LEMMA": "cannot", "POS": "AUX"}, # Modal auxiliary (e.g., "can", "can't)
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}      # Past participle (e.g., "ignored")
       ],

       [
           {"LEMMA": "cannot", "POS": "AUX"}, # Modal auxiliary (e.g., "can", "can't)
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}        # Past participle (e.g., "ignored")
       ],
       [
           {"LEMMA": "could", "POS": {"IN": ["VBD", "AUX"]}}, # Modal auxiliary (e.g., "can", "can't) # Fixed: Changed "IN" to {"IN": [...]}
            {"LOWER": "n't", "OP": "?"}, # Optional "not"
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}         # Past participle (e.g., "ignored")
       ],
       [
           {"LEMMA": "could", "POS": {"IN": ["VBD", "AUX"]}}, # Modal auxiliary (e.g., "can", "can't) # Fixed: Changed "IN" to {"IN": [...]}
            {"LOWER": "n't", "OP": "?"}, # Optional "not"
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}        # Past participle (e.g., "ignored")
       ],
       #8 MD "would" and "should"
       [
           {"LEMMA": {"IN": ["would", "should"]}, "POS": {"IN": ["AUX", "VB"]}},  # Modal auxiliaries # Fixed: Changed "IN": {"IN": [...]} to "IN": [...]
           {"LOWER": "not", "OP": "?"},
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}       # Past participle (e.g., "ignored")
       ],

       [
           {"LEMMA": {"IN": ["wouldn't", "shouldn't"]}, "POS": {"IN": ["VBD", "AUX"]}},  # Modal auxiliaries # Fixed: Changed "IN": to {"IN": [...]}
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VBN"}       # Past participle (e.g., "ignored")
       ],

       [
            {"LEMMA": {"IN": ["would", "should"]}, "POS": "AUX"},  # Modal auxiliaries
            {"LOWER": "not", "OP": "?"},
            {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
            {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}       # Past participle (e.g., "ignored")
       ],

       [
           {"LEMMA": {"IN": ["wouldn't", "shouldn't"]}, "POS": {"IN": ["VBD", "AUX"]}},  # Modal auxiliaries # Fixed: Changed "IN": to {"IN": [...]}
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
             {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}        # Past participle (e.g., "ignored")
       ],

       #9 MD "will"
       [
           {"LEMMA": "will", "POS": "AUX"},  # "will"
           {"LOWER": "not", "OP": "?"},      # Optional "not"
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
           {"TAG": "VBN"}        # Past participle (e.g., "ignored")
       ],
       [
           {"LEMMA": "will", "POS": "AUX"},  # "will"
           {"LOWER": "not", "OP": "?"},      # Optional "not"
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
           {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}       # Past participle (e.g., "ignored")
       ],

       [
           {"LOWER": "won't", "POS": "AUX"},  # "won't" as a single token
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
           {"TAG":"VBN"}        # Past participle (e.g., "ignored")
       ],

       [
           {"LOWER": "won't", "POS": "AUX"},  # "won't" as a single token
           {"LEMMA": "be", "POS": "AUX"},         # Auxiliary "be"
           {"TAG": "VB", "TEXT": {"REGEX": ".*(ed|d)$"}}       # Past participle (e.g., "ignored")
       ],

        [
    {"TAG": {"IN": ["NN", "NNS"]}, "DEP": {"IN": ["nsubj", "nsubjpass"]}},  # Match singular or plural noun subject
    {"LEMMA": "be", "TAG": {"IN": ["VBD", "VBZ", "VBP"]}},
     {"MORPH": {"IS_SUBSET": ["Number=Sing", "Number=Plur"]}},  # Match "be" with correct number
    {"TAG": "VBN"},  # Match past participle
]


]


   # Add patterns to the matcher
    # Corrected pattern structure within OR
    # Add patterns to the matcher
    matcher.add("CorrectPassiveVoice", patterns, greedy="LONGEST")

    # Find matches
    matches = matcher(doc, as_spans=True)
    count = len(matches)

    # Print each match (span of text that matches the pattern)
    print("Correct passive voice usages detected:")
    for match in matches:
        print(match.text)

    # Return the count of correct passive voice patterns
    return matches

# Example usage
text = "This will be considered. It is strongly influenced. The result is perfectly crafted. She was clearly happy to see it finished."
matches_list = correct(text)
correct_count = correct(text)
print(f"correct passive voice usages detected: {correct_count}")

from spacy.matcher import Matcher
import spacy

# Load the spaCy model
nlp = spacy.load("en_core_web_sm")

def error(new_text):
    # Parse the input text
    doc = nlp(new_text)
    matcher = Matcher(nlp.vocab)

    # Define patterns for passive voice detection
    # Define patterns for passive voice detection
    patterns = [

                #1 Singular Noun + AUX have
        [
             {"TAG": "NN", "MORPH": {"IS_SUBSET": ["Number=Sing"]}}, # Subject is third person plural
             {"POS": "AUX", "TAG": "VBP"},
             {"LEMMA": "be", "TAG": "VBN"},  # Auxiliary "be" in plural form (e.g., are)
             {"POS": "ADV", "OP": "?"},  # Optional adverb
             {"TAG": "VBN"},  # Past participle or verb base + suffix ed
        ],

                #2 noun non human in active voice
        [
        {"DEP": "nsubj", "TEXT": {"IN": ["topics", "rules", "concepts", "things"]}},  # Non-human subject
    {"TAG": "MD"},  # Modal auxiliary (e.g., should, would)
    {"TAG": "VB"},  # Active base verb (e.g., avoid, consider)
        ],

                #3 Plural Noun + BE singular
[
    {"TAG": "NNS", "DEP": "nsubj"},  # Match plural noun subject (e.g., "tyres")
    {"LEMMA": "be", "TAG": "VBD", "TEXT": "was"},  # Match singular "was"
    {"TAG": {"IN": ["VBN", "VBD"]}}, # Match past participle (e.g., "made")
],
                [

    {"TAG": "NNS", "DEP": {"IN": ["nsubj", "nsubjpass"]}},  # Match plural noun subject
    {"LEMMA": "be", "TAG": "VBD"},  # Match auxiliary "was"
    {"TAG": "VBN"},  # Match past participle (e.g., "made")
],


#4 I was learned, I am come
[
    {"POS": "PRON", "TAG": "PRP", "DEP": {"IN": ["nsubj", "nsubjpass"]}},  # Subject pronoun
    {"LEMMA": "be", "TAG": {"IN": ["AUX", "VBD", "VBZ", "VBP"]}},  # Auxiliary verb "be"
    {"LEMMA": {"IN":["learn", "come", "exist" "happen", "occur", "seem", "appear", "belong", "go", "come", "arrive", "depart", "walked", "run", "sleep", "die", "lie", "fall", "sit","rise", "belong", "consist", "have", "contain", "resemble", "lack", "depend", "fit", "cost"]}},
],

    ]
     # Add patterns to the matcher
    matcher.add("ErrorPassiveVoice", patterns, greedy="LONGEST")

    # Find matches
    matches = matcher(doc, as_spans=True)
    count = len(matches)

    # Print each match (span of text that matches the pattern)
    print("Error passive voice usages detected:")
    for match in matches:
        print(match)

    # Return the count of correct passive voice patterns
    return count

# Example usage
text= "This will be considered. It is strongly influenced. The result is perfectly crafted. She was clearly happy to see it finished."
error_count = error(text)
print(f"Error passive voice usages detected: {error_count}")

# Process each response and save correct counts and save in a new column
df['c_correct'] = df['text'].apply(correct)

# Process each response and save incorrect counts and save in a new column
df['c_error'] = df['text'].apply(error)

# Process each response and save correct counts and save in a new column
df['c_correct'] = df['new_text'].apply(lambda x: len(correct(x)))  # Get the length of the matches list

total_correct_no_zero = df[df['correct'] != 0]['correct'].sum()
total_c_correct_no_zero = df[df['c_correct'] != 0]['c_correct'].sum()

print(f"Total correct (excluding 0): {total_correct_no_zero}")
print(f"Total c_correct (excluding 0): {total_c_correct_no_zero}")

# prompt: sum the numbers in column error and c_error

total_error = df['error'].sum()
total_c_error = df['c_error'].sum()

print(f"Total error: {total_error}")
print(f"Total c_error: {total_c_error}")

# Troubleshoot your code

#ts_text = df.loc[1,'text']
ts_text = "I was attracted."


doc = nlp(ts_text)

for token in doc:
  print(token.text, token.pos_, token.tag_, token.morph)
  # print(token.text, token.pos_, end=' ')

"""Debug"""

def debug_matching(new_text):
    print(f"Text: {new_text}")
    print("Correct Matches:")
    for match in correct(new_text):
        print(f"  {match.new_text}")
    print("Error Matches:")
    for match in error(new_text):
        print(f"  {match.new_text}")

"""Evaluate Your Results"""

import pandas as pd
from sklearn.metrics import precision_score, recall_score, f1_score

actual  = df['correct'] # ground truth or gold standard, human annotation
predicted = df['c_correct']

# Calculate precision, recall, and F1 score
precision = precision_score(actual, predicted, average = 'macro')
recall = recall_score(actual, predicted, average = 'macro')
f1 = f1_score(actual, predicted, average = 'macro')

print(f"Precision: {precision:.2f}")
print(f"Recall: {recall:.2f}")
print(f"F1 Score: {f1:.2f}")

import pandas as pd
from sklearn.metrics import precision_score, recall_score, f1_score

actual  = df['error'] # ground truth or gold standard, human annotation
predicted = df['c_error']


# Calculate precision, recall, and F1 score
precision = precision_score(actual, predicted, average = 'macro')
recall = recall_score(actual, predicted, average = 'macro')
f1 = f1_score(actual, predicted, average = 'macro')

print(f"Precision: {precision:.2f}")
print(f"Recall: {recall:.2f}")
print(f"F1 Score: {f1:.2f}")

"""Step 6"""

# Process each response and save correct counts and save in a new column
df['c_correct'] = df['new_text'].apply(correct)

# Process each response and save incorrect counts and save in a new column
df['c_error'] = df['new_text'].apply(error)

# prompt: create a dataset with the column "correct", "error", "c_correct", "c_error" without the similar numbers

# Assuming df is your DataFrame with 'correct', 'error', 'c_correct', 'c_error' columns

# Create a new DataFrame without similar numbers in 'correct' and 'c_correct' columns
new_df = df[df['correct'] != df['c_correct']].copy()

# You can also filter based on other columns as needed, like:
# new_df = df[(df['correct'] != df['c_correct']) & (df['error'] != df['c_error'])].copy()

new_df

for text in new_df['new_text']:
  print(text)
  print("C Correct: ", correct(text))
  print("C Error: ", error(text))
  print("C Error: ", error(text))

# prompt: print false positive and fall negatives

# Assuming df is your DataFrame with 'correct', 'error', 'c_correct', 'c_error' columns

# False positives: Predicted as correct but actually incorrect
false_positives = df[(df['c_correct'] == 1) & (df['correct'] == 0)]
print("False Positives:")
print(false_positives)

# False negatives: Predicted as incorrect but actually correct
false_negatives = df[(df['c_correct'] == 0) & (df['correct'] == 1)]
print("\nFalse Negatives:")
false_negatives

